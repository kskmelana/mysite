<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title> (CCE Auto)</title>

  <style>
    :root{
      --bg:#f6f8ff;
      --card:#ffffff;
      --txt:#111;
      --muted:#666;
    }
    *{ box-sizing:border-box; }
    html, body{
      margin:0; padding:0;
      height:100%;
      background:var(--bg);
      font-family: system-ui, Arial, sans-serif;
      color:var(--txt);
      overflow:auto; /* scroll enabled */
    }
    .app{ max-width: 920px; margin:0 auto; padding:12px; display:flex; flex-direction:column; gap:10px; }
    .topbar{
      background:var(--card);
      border:1px solid rgba(0,0,0,0.08);
      border-radius:16px;
      padding:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .title{ font-weight:900; font-size:16px; line-height:1.2; }
    .sub{ font-size:12px; color:var(--muted); margin-top:4px; line-height:1.35; }
    .btn{
      border:none; border-radius:14px;
      padding:10px 12px;
      font-weight:900; font-size:13px;
      background:#eef1ff; cursor:pointer;
      white-space:nowrap;
    }
    .btn.primary{ background:#5166ff; color:white; }
    .btn.danger{ background:#ffecec; color:#b40000; }

    .panel{
      background:var(--card);
      border:1px solid rgba(0,0,0,0.08);
      border-radius:16px;
      padding:12px;
    }
    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ display:block; font-size:12px; font-weight:900; margin-bottom:6px; color:#222; }
    input[type="number"], input[type="file"], input[type="range"]{
      width:100%;
      padding:10px;
      border-radius:14px;
      border:1px solid #ddd;
      font-size:14px;
      outline:none;
      background:#fafafa;
    }
    input[type="range"]{ padding:0; height:36px; background:transparent; border:none; }
    .row2{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .badge{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      background:#f1f5ff;
      border:1px solid #d7e0ff;
      font-weight:900;
      color:#2a3cff;
      margin-left:8px;
    }

    .canvasWrap{
      background:#111;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,0.12);
      position:relative;
      max-height:70vh;
    }
    canvas{ width:100%; height:auto; display:block; touch-action:none; }

    .tip{
      position:absolute;
      left:10px; right:10px; bottom:10px;
      background:rgba(0,0,0,0.55);
      color:#fff;
      padding:10px 12px;
      border-radius:14px;
      font-size:12px;
      line-height:1.35;
      backdrop-filter: blur(6px);
    }

    .result{
      background:var(--card);
      border:1px solid rgba(0,0,0,0.08);
      border-radius:16px;
      padding:12px;
    }
    .rrow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:8px 0;
      border-bottom:1px dashed rgba(0,0,0,0.08);
      font-size:14px;
    }
    .rrow:last-child{ border-bottom:none; }
    .val{ font-weight:900; }
    .warn{ color:#b40000; font-weight:900; }
  </style>
</head>

<body>
<div class="app">

  <div class="topbar">
    <div>
      <div class="title">भू-नक्शा CCE Auto (Improved) <span class="badge">1 क्लिक</span> <span class="badge">1 कदम=0.75m</span></div>
      <div class="sub">
        1) Screenshot Upload करें  2) Hectare डालें  3) खेत के ग्रे हाइलाइट के अंदर 1 क्लिक करें।<br>
        यह version खेत को बेहतर detect करता है और खेत के angle के हिसाब से लंबाई/चौड़ाई निकालता है।
        (DEVELOED: BY MAYANK CHITTORA)
      </div>
    </div>
    <button class="btn danger" id="btnReset">Reset</button>
  </div>

  <div class="panel">
    <div class="grid">
      <div>
        <label>Screenshot Upload</label>
        <input id="file" type="file" accept="image/*" />
      </div>
      <div>
        <label>खेत का एरिया (हेक्टेयर)</label>
        <input id="haInput" type="number" inputmode="decimal" step="0.0001" placeholder="उदाहरण: 1.7100" />
      </div>
    </div>

    <div style="margin-top:10px;">
      <label>Sensitivity (खेत पकड़ने की ताकत)</label>
      <div class="row2">
        <input id="sens" type="range" min="15" max="60" value="35" />
        <div class="val"><span id="sensVal">35</span></div>
      </div>
      <div class="sub">
        अगर खेत कम/ज्यादा पकड़ रहा है तो slider बढ़ाएँ/घटाएँ।
      </div>
    </div>

    <div style="margin-top:10px; display:flex; gap:10px;">
      <button class="btn" id="btnClearPick">Clear Pick</button>
      <button class="btn primary" id="btnRecalc">Re-Calculate</button>
    </div>
  </div>

  <div class="canvasWrap">
    <canvas id="cv"></canvas>
    <div class="tip" id="tip">फोटो अपलोड करें → हेक्टेयर डालें → ग्रे खेत के अंदर 1 क्लिक करें।</div>
  </div>

  <div class="result">
    <div class="rrow"><div>लंबाई (मीटर)</div><div class="val" id="outLenM">0</div></div>
    <div class="rrow"><div>चौड़ाई (मीटर)</div><div class="val" id="outWidM">0</div></div>
    <div class="rrow"><div>लंबाई (कदम)</div><div class="val" id="outLenS">0</div></div>
    <div class="rrow"><div>चौड़ाई (कदम)</div><div class="val" id="outWidS">0</div></div>
    <div class="rrow"><div>एरिया (m²)</div><div class="val" id="outSqm">0</div></div>
    <div class="rrow"><div>एरिया (हेक्टेयर)</div><div class="val" id="outHa">0</div></div>
    
    <div class="rrow"><div>कदम गुणा (L×W)</div><div class="val" id="outStepMul">0</div></div>
    <div class="rrow"><div>Auto Constant (कदम²/हेक्टेयर)</div><div class="val" id="outK">0</div></div>
    <div class="rrow"><div>19600 के हिसाब से Adjusted लंबाई</div><div class="val" id="outAdjL">0</div></div>
    <div class="rrow"><div>19600 के हिसाब से Adjusted चौड़ाई</div><div class="val" id="outAdjW">0</div></div>
    <div class="rrow"><div>Check: Adj L×W ÷ 19600</div><div class="val" id="outAdjHa">0</div></div>

    <div class="rrow"><div>Status</div><div class="val" id="outStatus">Waiting...</div></div>
  </div>

</div>

<script>
  // Fixed
  const STEP_METER = 0.75;

  // Limits
  const MAX_PIXELS = 450000; // safety

  // Elements
  const file = document.getElementById("file");
  const haInput = document.getElementById("haInput");
  const sens = document.getElementById("sens");
  const sensVal = document.getElementById("sensVal");

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { willReadFrequently: true });

  const btnReset = document.getElementById("btnReset");
  const btnClearPick = document.getElementById("btnClearPick");
  const btnRecalc = document.getElementById("btnRecalc");
  const tip = document.getElementById("tip");

  // Outputs
  const outLenM = document.getElementById("outLenM");
  const outWidM = document.getElementById("outWidM");
  const outLenS = document.getElementById("outLenS");
  const outWidS = document.getElementById("outWidS");
  const outSqm = document.getElementById("outSqm");
  const outHa = document.getElementById("outHa");
  const outStepMul = document.getElementById("outStepMul");
  const outK = document.getElementById("outK");
  const outAdjL = document.getElementById("outAdjL");
  const outAdjW = document.getElementById("outAdjW");
  const outAdjHa = document.getElementById("outAdjHa");
  const outStatus = document.getElementById("outStatus");

  // State
  let img = new Image();
  let imgLoaded = false;
  let pick = null;

  // Result geometry
  let overlayMask = null;
  let geom = null; // {center, angle, Lpx, Wpx, corners}

  function resetAll(){
    pick = null;
    overlayMask = null;
    geom = null;
    haInput.value = "";
    outLenM.textContent='0'; outWidM.textContent='0'; outLenS.textContent='0'; outWidS.textContent='0'; outSqm.textContent='0'; outHa.textContent='0';
    outStepMul.textContent='0'; outK.textContent='0'; outAdjL.textContent='0'; outAdjW.textContent='0'; outAdjHa.textContent='0';
    update();
    outStatus.textContent = "Waiting...";
    tip.innerHTML = "Reset हो गया। फोटो अपलोड करें → हेक्टेयर डालें → खेत के अंदर 1 क्लिक करें।";
  }

  btnReset.onclick = resetAll;
  btnClearPick.onclick = () => {
    pick = null;
    overlayMask = null;
    geom = null;
    update();
    outStatus.textContent = "Pick cleared. अब खेत के अंदर क्लिक करें।";
  };

  btnRecalc.onclick = () => {
    if(!pick){
      outStatus.textContent = "पहले खेत के अंदर क्लिक करें।";
      return;
    }
    runAuto(pick.x, pick.y);
  };

  sens.addEventListener("input", () => {
    sensVal.textContent = sens.value;
    if(pick) runAuto(pick.x, pick.y);
  });

  // Image load
  file.addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if(!f) return;

    const url = URL.createObjectURL(f);
    img = new Image();
    img.onload = () => {
      imgLoaded = true;
      cv.width = img.naturalWidth;
      cv.height = img.naturalHeight;

      pick = null;
      overlayMask = null;
      geom = null;

      update();
      outStatus.textContent = "Photo loaded. खेत के अंदर क्लिक करें।";
    };
    img.src = url;
  });

  function getCanvasPos(evt){
    const rect = cv.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
    const x = (clientX - rect.left) * (cv.width / rect.width);
    const y = (clientY - rect.top) * (cv.height / rect.height);
    return {x: Math.round(x), y: Math.round(y)};
  }

  function fmt(n, d=2){
    if(!isFinite(n) || n <= 0) return "0";
    return Number(n).toFixed(d);
  }

  // --- Color utils
  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0,s=0,l=(max+min)/2;

    if(max!==min){
      const d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d + (g<b?6:0); break;
        case g: h=(b-r)/d + 2; break;
        case b: h=(r-g)/d + 4; break;
      }
      h/=6;
    }
    return {h,s,l};
  }

  // Pixel matches "highlight-like" area:
  // - low saturation (grey/green)
  // - medium lightness
  // plus: close to seed in HSL
  function matchPixel(r,g,b, seedHsl, tol){
    const hsl = rgbToHsl(r,g,b);

    // basic highlight constraints
    if(hsl.s > 0.35) return false;          // too colorful (blue lines etc.)
    if(hsl.l < 0.18 || hsl.l > 0.85) return false; // too dark/bright

    // HSL distance to seed (h wrap)
    let dh = Math.abs(hsl.h - seedHsl.h);
    dh = Math.min(dh, 1-dh);
    const ds = Math.abs(hsl.s - seedHsl.s);
    const dl = Math.abs(hsl.l - seedHsl.l);

    // tol from slider
    // scale: dh ~0..0.5, ds/dl 0..1
    const score = (dh*1.2) + (ds*1.0) + (dl*1.4);
    return score <= (tol/100);
  }

  // --- PCA for oriented rectangle
  function computeOrientedRect(points){
    // points: array of {x,y} (sampled)
    const n = points.length;
    if(n < 20) return null;

    // centroid
    let mx=0,my=0;
    for(const p of points){ mx+=p.x; my+=p.y; }
    mx/=n; my/=n;

    // covariance
    let cxx=0,cxy=0,cyy=0;
    for(const p of points){
      const dx=p.x-mx, dy=p.y-my;
      cxx += dx*dx;
      cxy += dx*dy;
      cyy += dy*dy;
    }
    cxx/=n; cxy/=n; cyy/=n;

    // principal angle
    const angle = 0.5 * Math.atan2(2*cxy, (cxx - cyy));

    // rotate points to principal axes
    const ca = Math.cos(-angle);
    const sa = Math.sin(-angle);

    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    for(const p of points){
      const rx = (p.x-mx)*ca - (p.y-my)*sa;
      const ry = (p.x-mx)*sa + (p.y-my)*ca;
      if(rx<minX) minX=rx;
      if(rx>maxX) maxX=rx;
      if(ry<minY) minY=ry;
      if(ry>maxY) maxY=ry;
    }

    const W = (maxX - minX);
    const L = (maxY - minY);

    // corners in rotated space
    const cornersR = [
      {x:minX, y:minY},
      {x:maxX, y:minY},
      {x:maxX, y:maxY},
      {x:minX, y:maxY},
    ];

    // rotate back
    const ca2 = Math.cos(angle);
    const sa2 = Math.sin(angle);

    const corners = cornersR.map(c => {
      const x = c.x*ca2 - c.y*sa2 + mx;
      const y = c.x*sa2 + c.y*ca2 + my;
      return {x,y};
    });

    // Ensure length is bigger
    let Lpx = Math.max(W, L);
    let Wpx = Math.min(W, L);

    // If swapped, rotate by 90 deg to keep angle consistent
    let finalAngle = angle;
    if(L < W){
      finalAngle = angle + Math.PI/2;
    }

    return {
      center:{x:mx,y:my},
      angle: finalAngle,
      Lpx, Wpx,
      corners
    };
  }

  function runAuto(px, py){
    const ha = parseFloat(haInput.value);
    if(!isFinite(ha) || ha <= 0){
      outStatus.innerHTML = "<span class='warn'>पहले हेक्टेयर डालें।</span>";
      return;
    }
    if(!imgLoaded){
      outStatus.innerHTML = "<span class='warn'>पहले फोटो अपलोड करें।</span>";
      return;
    }

    outStatus.textContent = "Processing...";
    update();

    const tol = parseInt(sens.value, 10); // 15..60
    const imgData = ctx.getImageData(0,0,cv.width,cv.height);
    const data = imgData.data;
    const w = cv.width, h = cv.height;

    const idx0 = (py*w + px)*4;
    const sr = data[idx0], sg = data[idx0+1], sb = data[idx0+2];
    const seedHsl = rgbToHsl(sr,sg,sb);

    const visited = new Uint8Array(w*h);
    const mask = new Uint8Array(w*h);

    // queue
    const qx = new Int32Array(Math.min(w*h, MAX_PIXELS));
    const qy = new Int32Array(Math.min(w*h, MAX_PIXELS));
    let qh=0, qt=0;

    function push(x,y){
      qx[qt]=x; qy[qt]=y; qt++;
    }

    push(px,py);
    visited[py*w+px]=1;

    let count=0;
    let minX=px, maxX=px, minY=py, maxY=py;

    // sample points for PCA (downsample)
    const sample = [];

    while(qh < qt){
      const x = qx[qh], y = qy[qh]; qh++;
      const p = y*w + x;

      const ii = p*4;
      const r = data[ii], g = data[ii+1], b = data[ii+2];

      if(matchPixel(r,g,b, seedHsl, tol)){
        mask[p]=1;
        count++;

        if(x<minX) minX=x;
        if(x>maxX) maxX=x;
        if(y<minY) minY=y;
        if(y>maxY) maxY=y;

        // sample every ~40 pixels
        if((count % 40) === 0){
          sample.push({x,y});
        }

        if(count >= MAX_PIXELS) break;

        // 4-neighbors
        if(x>0){
          const p2 = p-1;
          if(!visited[p2]){ visited[p2]=1; push(x-1,y); }
        }
        if(x<w-1){
          const p2 = p+1;
          if(!visited[p2]){ visited[p2]=1; push(x+1,y); }
        }
        if(y>0){
          const p2 = p-w;
          if(!visited[p2]){ visited[p2]=1; push(x,y-1); }
        }
        if(y<h-1){
          const p2 = p+w;
          if(!visited[p2]){ visited[p2]=1; push(x,y+1); }
        }
      }
    }

    if(count < 2500){
      outStatus.innerHTML = "<span class='warn'>खेत detect नहीं हुआ। ग्रे हाइलाइट के अंदर क्लिक करें या Sensitivity बदलें।</span>";
      overlayMask = null;
      geom = null;
      outStepMul.textContent='0'; outK.textContent='0'; outAdjL.textContent='0'; outAdjW.textContent='0'; outAdjHa.textContent='0';
      update();
      return;
    }

    // Compute oriented rectangle
    const rect = computeOrientedRect(sample);
    if(!rect || rect.Lpx < 10 || rect.Wpx < 10){
      outStatus.innerHTML = "<span class='warn'>Rectangle नहीं बन पाया। दुबारा क्लिक करें।</span>";
      overlayMask = null;
      geom = null;
      outStepMul.textContent='0'; outK.textContent='0'; outAdjL.textContent='0'; outAdjW.textContent='0'; outAdjHa.textContent='0';
      update();
      return;
    }

    // Save state
    pick = {x:px,y:py};
    overlayMask = mask;
    geom = rect;

    // Ratio from pixels
    const ratio = rect.Lpx / rect.Wpx;

    // Real area
    const areaSqm = ha * 10000;

    // Solve rectangle dims
    const Wm = Math.sqrt(areaSqm / ratio);
    const Lm = ratio * Wm;

    // Steps rounded
    const LsR = Math.round(Lm / STEP_METER);
    const WsR = Math.round(Wm / STEP_METER);

    // Output
    outLenM.textContent = fmt(Lm,2) + " m";
    outWidM.textContent = fmt(Wm,2) + " m";
    outLenS.textContent = LsR + " कदम";
    outWidS.textContent = WsR + " कदम";
    outSqm.textContent = fmt(areaSqm,2) + " m²";
    outHa.textContent = fmt(ha,4) + " ha";

    // --- New: Step-math based adjustment for 19600
    const BASE_DIV = 19600;
    const Ls = LsR;
    const Ws = WsR;
    const mul = Ls * Ws;
    outStepMul.textContent = mul.toString();

    // K = (steps^2)/hectare (your field-specific constant)
    const K = mul / ha;
    outK.textContent = fmt(K, 2);

    // Scale both steps proportionally so that (AdjL*AdjW)/19600 == hectare
    // s = sqrt((ha*19600)/(L*W))
    const s = Math.sqrt((ha * BASE_DIV) / mul);
    const adjL = Math.round(Ls * s);
    const adjW = Math.round(Ws * s);
    outAdjL.textContent = adjL + " कदम";
    outAdjW.textContent = adjW + " कदम";
    outAdjHa.textContent = fmt((adjL * adjW) / BASE_DIV, 4) + " ha";

    outStatus.textContent = "Done ✔ (Improved)";
    update();
  }

  function drawOverlay(){
    if(!overlayMask || !geom) return;

    const w = cv.width, h = cv.height;

    // light tint (fast) using bbox scan
    // bbox from corners
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const c of geom.corners){
      if(c.x<minX) minX=c.x;
      if(c.x>maxX) maxX=c.x;
      if(c.y<minY) minY=c.y;
      if(c.y>maxY) maxY=c.y;
    }
    minX = Math.max(0, Math.floor(minX));
    minY = Math.max(0, Math.floor(minY));
    maxX = Math.min(w-1, Math.ceil(maxX));
    maxY = Math.min(h-1, Math.ceil(maxY));

    const imgData = ctx.getImageData(minX,minY,(maxX-minX+1),(maxY-minY+1));
    const data = imgData.data;
    const ww = (maxX-minX+1);

    for(let y=0; y<(maxY-minY+1); y++){
      const row = y*ww;
      for(let x=0; x<ww; x++){
        const p = (minY+y)*w + (minX+x);
        if(overlayMask[p]){
          const i = (row + x)*4;
          data[i]   = Math.min(255, data[i] + 0);
          data[i+1] = Math.min(255, data[i+1] + 35);
          data[i+2] = Math.min(255, data[i+2] + 0);
        }
      }
    }
    ctx.putImageData(imgData, minX, minY);

    // Draw oriented rectangle
    ctx.lineWidth = 10;
    ctx.strokeStyle = "#00ff7a";
    ctx.beginPath();
    ctx.moveTo(geom.corners[0].x, geom.corners[0].y);
    for(let i=1;i<geom.corners.length;i++){
      ctx.lineTo(geom.corners[i].x, geom.corners[i].y);
    }
    ctx.closePath();
    ctx.stroke();

    // Draw pick
    if(pick){
      ctx.beginPath();
      ctx.arc(pick.x, pick.y, 14, 0, Math.PI*2);
      ctx.fillStyle = "#00ff7a";
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "white";
      ctx.stroke();
    }
  }

  function update(){
    ctx.clearRect(0,0,cv.width,cv.height);

    if(imgLoaded){
      ctx.drawImage(img,0,0);
      drawOverlay();
    } else {
      cv.width = 900;
      cv.height = 550;
      ctx.fillStyle = "#111";
      ctx.fillRect(0,0,cv.width,cv.height);
      ctx.fillStyle = "#fff";
      ctx.font = "28px system-ui";
      ctx.fillText("Screenshot Upload करें", 40, 80);
      return;
    }
  }

  function handlePick(pos){
    pick = pos;
    overlayMask = null;
    geom = null;
    update();
    runAuto(pos.x, pos.y);
  }

  cv.addEventListener("click", (evt) => {
    if(!imgLoaded) return;
    handlePick(getCanvasPos(evt));
  });

  cv.addEventListener("touchstart", (evt) => {
    if(!imgLoaded) return;
    evt.preventDefault();
    handlePick(getCanvasPos(evt));
  }, {passive:false});

  haInput.addEventListener("input", () => {
    if(pick) runAuto(pick.x, pick.y);
  });

  sensVal.textContent = sens.value;
  resetAll();
</script>

</body>
</html>
